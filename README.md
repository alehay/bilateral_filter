## **Кластеризация траекторий автомобилей с помощью dbscan**

На основе анализа различных методов, реализованных, как в [opencv](https://docs.opencv.org), так и в [scikit-learn](https://scikit-learn.org/stable/index.html), 
был выбран метод кластеризации **DBSCAN**. 

Содержание
==========
* [Введение](#введение) 
* [Описание задачи](#описание-задачи)
* [Сравнительный анализ различных методов кластеризации](#сравнительный-анализ-различных-методов-кластеризации)
* [Алгоритм работы](#алгоритм-работы)
    * [Загрузка данных](#загрузка-данных)
	* [Чтение данных](#чтение-данных)
	* [Установка параметров кластеризации](установка-параметров-кластеризации)
	* [Запуск кластеризации](#запись-данных)
* [Визуализация результатов](#визуализация-результатов)


---


Введение
========

Практически был исследованы:

* метод k-средних  [opencv](https://docs.opencv.org/master/d1/d5c/tutorial_py_kmeans_opencv.html)
* метод dbscan  [scikit-learn](https://scikit-learn.org/stable/modules/clustering.html#dbscan),
* написана своя реализация метода ["Самоорганизующая карта Кохонена"](https://en.wikipedia.org/wiki/Self-organizing_map),
  
Метод **k-средних**, как и метод **разделения вокруг медоидов** (PAM clustering), подходят для поиска кластеров сферической формы или выпуклых кластеров. Другими словами, они подходят только для компактных и хорошо разделенных кластеров. Более того, на них также сильно влияет наличие шума в данных. 
Метод **SOM** исследовался на недостаточно информативных параметрах, поэтому был первоначально отвергнут. Сейчас, возможно, требуется пересмотреть его использование и добавить, как корректирующий метод или метод для поиска центров кластера.

---

Описание задачи
===============

Даны точки (x, y, time), которые характеризуют перемещение объекта во времени. Отслеживается нижняя, средняя по ширине, точка прямоугольника, bbox-а, отслеживающая передвижение автомобиля по экрану размером ```[640 x 480]```. 

*Трёхмерное изображение точек без принадлежности к какому-либо треку:*

![](images/tracks_points_by_time1.jpg)

---

*Вертикальные "столбики" - это автомобили, стоящие на светофоре:*

![](images/tracks_points_by_time2.jpg)

---

*Ситуацию можно проследить по bbox №308 (на трёхмерном графике лиловый цвет), который стоит на красном сигнале светофора, 
и bbox №348 (на трёхмерном графике зелёный цвет), который едет на зелёный сигнал:*

![](images/traffic_light.jpg)

---

*Трёхмерное изображение точек без принадлежности к какому-либо треку с цветным градиентом, характеризующим площадь bbox-ов. 
Синий цвет - самый маленький размер, красный - самый большой. В привязке к основному изображению:*

![](images/tracks_points_by_time_colorsize1.jpg)

---

*3D изображения с разных сторон:*

![](images/tracks_points_by_time_colorsize2.jpg)

---

![](images/tracks_points_by_time_colorsize3.jpg)

---

![](images/tracks_points_by_time_colorsize4.jpg)

---

![](images/tracks_points_by_time_colorsize5.jpg)

---

Сравнительный анализ различных методов кластеризации
====================================================

 Методы реализованы в библиотеке [scikit-learn](https://scikit-learn.org/stable/index.html) на языке python.
 
 ![](images/sphx_glr_plot_cluster_comparison_001.png)

В **DBSCAN**, в отличие от k-средних, не нужно задавать количество кластеров, он определяет его сам, работает быстрее и точнее на множествах кластеров различной формы, имеет два параметра:

* *eps* - радиус от объекта до соседних объектов кластера. Все объекты, которые расположены не менее eps от любого ядра кластера, считаются "посторонними", не входящими в этот кластер, 
* *min_samples* - минимальное количество элеметов, образующих кластер:

 ![](https://github.com/dariaemacs/cv_images/blob/main/dbscan_parameters.png?raw=true)

 
Кластеризация с помощью **DBSCAN** 750-ти двумерных объектов, с параметрами **eps = 0.2**, **min_samples = 5**. Черные точки - это шум, то есть объекты, которые не принадлежат ни одному кластеру: 
 
 ![](https://github.com/dariaemacs/cv_images/blob/main/three_clusters.png?raw=true)
 
 
**Основная часть скрипта для генерации графика с кластерами из 750 объектов.**
 
 
``` 
# #############################################################################
# Generate sample data

centers = [[1, 1], [-1, -1], [1, -1]]
X, labels_true = make_blobs(n_samples=750, centers=centers, cluster_std=0.4,
                            random_state=0)

X = StandardScaler().fit_transform(X)


# #############################################################################
# Compute DBSCAN
db = DBSCAN(eps=0.2, min_samples=5, metric='euclidean').fit(X)
core_samples_mask = np.zeros_like(db.labels_, dtype=bool)
core_samples_mask[db.core_sample_indices_] = True
labels = db.labels_
...
plt.title('DBSCAN: eps = 0.2, min_samples = 5. Object number = 750, center points: (1, 1), (-1, -1), (1, -1), СКО = 0.4. Cluster number: %d' % n_clusters_)
plt.show()
```

---

Алгоритм работы
===============

Внутри три скрипта `scripts/*` и управляющая программа `clusterization.*`, но запускается одной командой: `cmake . && make && ./clusterization`.
Можно запустить с флагом *--only_read*, если необходимо запустить только кластеризацию, по уже сохраненным данным в папке **tracks**.

Загрузка данных
===============

#### Clusterization::get_data_from_csv()

* загрузка данных из дампа БД производится скриптом _csv2file.py_ внутри c++ кода. 
    * дамп создан с помощью команд:
    * `\c tracker_db` (подключиться к БД tracker_db)
    * `\copy (SELECT * FROM objects) TO '/tmp/file_obj.csv' DELIMITER ',' CSV HEADER`
    * `\copy (SELECT * FROM objects_motion) TO '/tmp/file_mobj.csv' DELIMITER ',' CSV HEADER`, для объектов и их перемещений соответственно в файлы: `file_obj.csv` и `file_mobj.csv`.


|_file_obj.csv_
| ------------------------------------------------------------------------------------------------------------- |
|**id,classId,parentId,trackId,ctrlId,tStart,tEnd,tag,dead,uuid**                                               |
|7825,6787,,6,5,2020-12-31 17:20:31.176,2020-12-31 17:22:38.781,"",f,bea2c109-2395-47e0-ba42-309759db1fa0       |
|7840,6773,,56,20,2020-12-31 17:22:32.905,2020-12-31 17:24:01.769,"",f,3f932156-7f89-4936-ad74-2d61f0b375e6     |
|7851,6787,,86,31,2020-12-31 17:24:58.142,2020-12-31 17:26:24.049,"",f,62b860ec-72d2-485a-ae2a-dd8984d9a265     |
|                                                                                                               |



| _file_mobj.csv_                                                                                                 |
| --------------------------------------------------------------------------------------------------------------- |
|**id,sourceId,objectId,classId,xc,yc,width,height,time,state,duration,xcGlob,ycGlob,widthGlob,heightGlob,uuid**  |
|245290,76,7821,6773,357,260,54,26,2020-12-31 17:21:01.022,"",-1,-1,-1,-1,-1,144aa090-16f7-47b7-9de8-4175249f2ffb |
|245291,76,7822,6773,281,260,42,23,2020-12-31 17:21:01.022,"",-1,-1,-1,-1,-1,9c30cc2f-99f2-4821-bebe-b82768ec63bc |
|250157,76,7838,6787,496,254,36,19,2020-12-31 17:28:58.123,"",-1,-1,-1,-1,-1,b5fb5504-0dc0-4978-aa2b-ef4e08393c94 |
|                                                                                                                 |



**Структура, создаваемая скриптом:**



```
├── tracks
│   └── 01_SiteID_100_1_Direction_SB_Period#1_2020_10_27_12_0_19_+_4_hours
│       ├── bbox_list.txt  
│       ├── complex
│       │   ├── bbox100.dat
│       │   ├── bbox98.dat
        .
        .
        .
│       │   ├── bbox999.dat
│       │   └── bbox9.dat
│       ├── coords.dat
│       ├── coords_time.dat
│       ├── coords_time_ids.dat
└── timeline/
```

* **bbox_list.txt** -- содержит id треков, которые удовлетворяют условию (tEnd - tStart) > 10 (назовём их "правильными"),
* **complex** -- содержит координаты всех "правильных" треков,
    * Каждый файл в директории **complex** сортируется по значению time в порядке возрастания с помощью скрипта `scripts/sorting_by_time.sh`
    
---

Чтение данных
=============

#### Clusterization::read()

   * зачитывает из bbox_list.txt список "правильных" треков.

---

Установка параметров кластеризации
==================================

#### Clusterization::set_features()

   * читает координаты, время, ширину и высоту bbox каждого трека
   * считает норму по координате x, а потом приводит к x-диапазону все остальные величины (у координату всех точек и площадь):

   ![](https://latex.codecogs.com/gif.latex?%5Cdpi%7B120%7D%20%5CLARGE%20%7By%5E%7B%27%7D%7D%3D%5Cfrac%7B%28y%20-%20y_%7Bmin%7D%29%5Ccdot%7Bx_%7Bnorm%7D%7D%7D%7By_%7Bnorm%7D%7D&plus;x_%7Bmin%7D)

   ![](https://latex.codecogs.com/gif.latex?%5Cdpi%7B120%7D%20%5CLARGE%20%7Bs%5E%7B%27%7D%7D%3D%5Cfrac%7B%28s-s_%7Bmin%7D%29%5Ccdot%7Bx_%7Bnorm%7D%7D%7D%7Bs_%7Bnorm%7D%7D%20&plus;%20x_%7Bmin%7D)

   * разделяет на равные отрезки всю ломаную каждого трека:

---

Тестовый пример. Синие точки --- точки ломаной, красные точки --- точки, рассчитанные при N = 10:

![Тестовый пример. Синие точки --- точки ломаной, красные точки --- точки, рассчитанные при N = 10.](images/equal_distance_test.jpg)

---

Двумерная ломаная для трека №1055. Синие точки --- точки ломаной, красные точки --- точки, рассчитанные при N = 10:

![Двумерная ломаная для трека №1055. Синие точки --- точки ломаной, красные точки --- точки, рассчитанные при N = 10.](images/equal_distance1055_2d.jpg)

---

Передвижение автомобиля №1055 разбито на одинаковые участки в 3D, по оси z - время в секундах. Точки размером 1 - точки ломаной, точки размером 3 - точки, рассчитанные при N = 10:

![Передвижение автомобиля №1055 разбито на одинаковые участки в 3D, по оси z - время в секундах. Точки размером 1 - точки ломаной, точки размером 3 - точки, рассчитанные при N = 10.](images/equal_distance_1055.gif)

---

Случайный трек, разбитый на равные участки. 

![](images/equal_distance_sample.gif)

---

Запуск кластеризации
====================

#### Clusterization::run()

   * запускает тот метод кластеризации, который был передан в параметрах (сейчас это **dbscan**),
   * запускает скрипт `scripts/dbscan_time.py`,
   * происходит кластеризация по параметрам, записанным на предыдущих шагах в файл `coords_time.dat` (11 точек (x, y) и площадь), параметры **DBSCAN** `eps=120, min_samples=3`, на выходе - массив из целых чисел (меток) от -1 до M, где -1 означает, что этот трек не принадлежит ни какому кластеру,
   * записывает id трека и номер его кластера в файл `coords_cluster_time.dat`

--- 

Запись данных
=============

#### Clusterization::write_clusters()

   * запись данных в нужном формате для интерактивной кластеризации в директорию `timeline`
   * генерация скриптов: `coords_cluster_time.sc` и `track_cluster_time.sc`
   
   

```
timeline/
├── bbox100.dat
├── bbox101.dat
├── bbox102.dat
...
├── bbox999.dat
├── bbox9.dat
├── cluster10.dat
├── cluster11.dat
├── cluster12.dat
├── cluster2.dat
├── cluster3.dat
├── cluster4.dat
├── cluster5.dat
├── cluster6.dat
├── cluster7.dat
├── cluster8.dat
└── cluster9.dat
```


---

Визуализация результатов
========================

Для отображения данных используется программа [gnuplot](http://www.gnuplot.info/).
   * создание интерактивного 3D изображения кластеров по последним точкам каждого трека: 
     `$ gnuplot coords_cluster_time.sc`
![](images/cluster_11_lastpoints.gif)
   * создание интерактивного 3D изображения кластеров по трекам: 
     `$ gnuplot track_cluster_time.sc`
![](images/cluster_11.gif)
